//code library
//EagleBear
#include <bits/stdc++.h>
#include <cstdio>

typedef long long LL;
const int MAXN = 1000000 + 10;
const int INF = 0x3f3f3f3f;

int getint() {
	char ch;
	while(('9' < (ch = getchar()) || ch < '0') && ch != '-');
	bool neg = ch == '-';
	int ans = neg ? 0 : ch - '0';
	while('0' <= (ch = getchar()) && ch <= '9')
		ans = (ans << 1) + (ans << 3) + ch - '0';
	return neg ? -ans : ans;
}

struct Edge {
	int from, to, dist;
	Edge* nxt;
	Edge(int from = 0, int to = 0, int dist = 0, Edge* nxt = NULL):
		from(from), to(to), dist(dist), nxt(nxt) {}
	inline bool operator < (const Edge obj) const {
		return dist < obj.dist;
	}
};
Edge* head[MAXN];

bool vis[MAXN];
int prime[MAXN];
int cnt = 0;
void Sieve(int n) {
	for(int i = 2; i <= n; ++i) {
		if(!vis[i]) prime[++cnt] = i;
		for(int j = 1; j <= cnt && prime[j] <= n / i; ++j) {
			vis[prime[j] * i] = true;
			if(i % prime[j] == 0) break;
		}
	}
}

int Power(int a, int k, int MOD) {
	int ans = 1;
	while(k) {
		if(k & 1) ans = ans * 1LL * a %MOD;
		a = a * 1LL * a % MOD, k >>= 1;
	}
	return ans;
}

//untested
int dist[MAXN];
void SPFA(int s) {
	memset(dist, 0x3f, sizeof dist);
	std::queue<int> que;
	dist[s] = 0, que.push(s);
	while(!que.empty()) {
		int u = que.front();
		que.pop();
		for(Edge* edg = head[u]; edg; edg = edg->nxt) {
			int v = edg->to;
			if(dist[v] > dist[u] + edg->dist)
				dist[v] = dist[u] + edg->dist, que.push(v);
		}
	}
}

struct Node {
	int id, dist;
	Node(int id = 0, int dist = 0):
		id(id), dist(dist) {}
	bool operator < (const Node& obj) const {
		return dist > obj.dist;
	}
};

//untested
void Dijkstra(int s) {
	memset(dist, 0x3f, sizeof dist);
	std::priority_queue<Node> heap;
	dist[s] = 0, heap.push(Node(s, 0));
	while(!heap.empty()) {
		int u = heap.top().id;
		heap.pop();
		if(vis[u]) continue;
		vis[u] = true;
		for(Edge* edg = head[u]; edg; edg = edg->nxt) {
			int v = edg->to;
			if(dist[v] > dist[u] + edg->dist)
				dist[v] = dist[u] + edg->dist, heap.push(Node(v, dist[v]));
		}
	}
}

class BinaryIndexTree {
private:
	LL s[MAXN];
	inline int lowbit(int x) {
		return x & -x;
	}
	
public:
	int n;
	void insert(int pos, int key) {
		for(int i = pos; i <= n; i += lowbit(i))
			s[i] += key;
	}
	
	LL getsum(int pos) {
		LL ans = 0;
		for(int i = pos; i; i -= lowbit(i))
			ans += s[i];
		return ans;
	}
	
	LL getsum(int l, int r) {
		return getsum(r) - getsum(l-1);
	}
	
	BinaryIndexTree(int n): n(n){
		memset(s, 0, sizeof s);
	} 
};

void Gauss(double a[][MAXN], int n) {
	for(int i = 1; i <= n; ++i) {
		int r = i;
		for(int j = i+1; j <= n; ++j)
			if(fabs(a[j][i]) > fabs(a[r][i])) r = j;
		for(int j = 1; j <= n+1; ++j)
			std::swap(a[i][j], a[r][j]);
		for(int j = 1; j <= n; ++j) if(j != i) {
			double rate = a[j][i] / a[i][i];
			for(int k = i; k <= n+1; ++k)
				a[j][k] -= a[i][k] * rate;
		}
	}
	for(int i = 1; i <= n; ++i)
		a[i][n+1] /= a[i][i];
}

int Euler(int n) {
	int ans = n;
	for(int i = 1; prime[i] <= n; ++i) {
		int p = prime[i];
		if(n % p == 0) {
			while(n % p == 0) n /= p;
			ans = ans / p * (p-1);
		}
	}
	return ans;
}

//20.10.08 
bool MillerRabin(int n) {
	if(n == 2) return true;
	if(n < 2 || (n & 1) == 0) return false;
	
	int cnt = 8;
	int k = 0, t = n-1;
	while((t & 1) == 0) ++k, t >>= 1;
	while(cnt--) {
		int s = Power(rand() % (n-1) + 1, t, n);
		for(int j = 1; j <= k; ++j) {
			int tmp = s * 1LL * s % n;
			if(s == 1 && tmp != 1 && tmp != n-1)
				return false;
			s = tmp;
		}
		if(s != 1) return false;
	}
	return true;
}

//20.10.14
int phi[MAXN];
void EulerSieve(int n) {
	phi[1] = 1;
	for(int i = 2; i <= n; ++i) if(!phi[i])
		for(int j = i; j <= n; j += i) {
			if(!phi[j]) phi[j] = j;
			phi[j] = phi[j] * (i-1) / i;
		}
}

//Baby Step Giant Step 
//a ^ x == b (mod p)
//a and p relatively-prime 
int BSGS(int a, int b, int p) {
	std::map<int, int> hash;
	a %= p, b %= p;
	int t = std::ceil(std::sqrt(p));
	
	for(int r = 0; r < t; ++r) {
		int key = b * 1LL * Power(a, r, p) % p;
		hash[key] = r;
	}
	
	if(!a) return b == 0 ? 1 : -1;
	for(int k = 0; k <= t; ++k) {
		int key = Power(a, t*k, p);
		int r = -1;
		if(hash.count(key)) r = hash[key];
		if(r >= 0 && t * k - r >= 0) return t * k - r;
	}
	return -1;
}

//18.07.29
template<typename Type>
struct Heap {
	const static int Root = 1;
	Type node[MAXN];
	int size;
	
	Heap(): size(0) {}
	
	void pushup(int rt){
		while(node[rt>>1] > node[rt] && rt > Root) {
			std::swap(node[rt], node[rt >>= 1]);
		}
	}
	
	void pushdown(int rt) {
		while(rt << 1 <= size) {
			int s = rt << 1;
			if(s < size && node[s+1] < node[s]) s++;
			if(node[rt] <= node[s]) return;
			std::swap(node[s], node[rt]), rt = s;
		}
	}
	
	void insert(Type key) {
		node[++size] = key, pushup(size);
	}
	
	Type top() {
		return node[Root];
	}
	
	void pop() {
		node[Root]=node[size--], pushdown(Root);
	}
	
	int search(int rt, Type key) {
		if(node[rt] > key) return 0;
		if(node[rt] == key) return rt;
		int s = rt << 1;
		if(int ans = search(s, key)) return ans;
		if(int ans = search(s+1,key)) return ans;
		return 0;
	}
	
	void erase(Type key) {
		int rt = search(Root, key);
		node[rt] = node[size], pushdown(rt);
	}
	
	void print() {
		for(int i = 1; i <= size; ++i)
			printf("node[%d] = %lld\n", i, node[i]);
	}
	
	void sort() {
		std::deque<int> tmp;
		while(size)
			tmp.push_back(top()),
			printf("%lld ", top()), pop();
		while(tmp.empty()==false)
			insert(tmp.front()), tmp.pop_front();
	}
};

//18.07.13
LL sum[MAXN];
struct SegmentTreeinPointer {
	struct Node {
		int l, r;
		LL sum, lz;
		Node* lch, * rch;
	};
	typedef Node* iterator;
	iterator Root;
	
	void build(int n) {
		insert(Root,1,n);
	}
	
	void insert(iterator& rt, int l, int r) {
		rt=new Node;
		rt->l=l, rt->r=r, rt->lz=0;
		rt->sum = sum[rt->r] - sum[rt->l-1];
		rt->lch = rt->rch = NULL;
	}
 	
	void pushup(iterator rt ) {
		rt->sum = rt->lch->sum + rt->rch->sum;
	}
	
	void pushdown(iterator rt) {
		rt->lch->sum += (rt->lch->r - rt->lch->l + 1) * rt->lz;
		rt->lch->lz += rt->lz;
		rt->rch->sum += (rt->rch->r - rt->rch->l+1) * rt->lz;
		rt->rch->lz += rt->lz;
		rt->lz = 0;
	}
	
	void update(iterator rt, int l, int r, int key) {
		if(r < rt->l || rt->r < l) return;
		if(l <= rt->l && rt->r <= r) {
			rt->sum += (rt->r-rt->l + 1LL) * key, rt->lz += key;
			return;
		}
		if(rt->lch == NULL) insert(rt->lch, rt->l, (rt->l + rt->r) >> 1);
		if(rt->rch == NULL) insert(rt->rch, (rt->l + rt->r) / 2 + 1, rt->r);
		if(rt->lz) pushdown(rt);
			
		update(rt->lch,l,r,key), update(rt->rch,l,r,key), pushup(rt);
	}
	
	LL getsum(iterator rt, int l, int r) {
		if(r<rt -> l || rt->r < l) return 0;
		if(l <= rt->l && rt->r <= r) return rt->sum;
			
		if(rt->lch == NULL) insert(rt->lch, rt->l, (rt->l + rt->r) / 2);
		if(rt->rch == NULL) insert(rt->rch, (rt->l+rt->r) / 2 + 1, rt->r);
		if(rt->lz) pushdown(rt);
		LL ret = getsum(rt->lch, l, r) + getsum(rt->rch, l, r);
		return pushup(rt), ret;
	}
};

//18.07.13
int a[MAXN];
struct SegmentTree_Single {
	struct Node {
		int l, r;
		LL sum, lz;
	};
	Node node[MAXN << 2];
	
	void Build(int rt, int l, int r) {
		node[rt].l = l, node[rt].r = r;
		if(l == r) return node[rt].sum = a[l], void();
		
		int s = rt << 1, mid = (l+r) >> 1;
		Build(s, l, mid), Build(s+1, mid+1, r);
		Pushup(rt);
	}
	
	void Pushup(int rt) {
		int s = rt << 1;
		node[rt].sum = node[s].sum + node[s+1].sum;
	}
	
	void Pushdown(int rt) {
		int s = rt << 1;
		node[s].sum += node[rt].lz * (node[s].r - node[s].l + 1);
		node[s].lz += node[rt].lz;
		node[s+1].sum += node[rt].lz * (node[s+1].r - node[s+1].l + 1);
		node[s+1].lz += node[rt].lz;
		node[rt].lz = 0;
	}
	
	void Update(int rt, int l, int r, int key) {
		if(r < node[rt].l || node[rt].r < l) return;
		if(l <= node[rt].l && node[rt].r <= r) {
			node[rt].sum += key * (node[rt].r - node[rt].l + 1);
			return node[rt].lz += key, void();
		}
		if(node[rt].lz) Pushdown(rt);
			
		int s = rt << 1;
		Update(s, l, r, key), Update(s+1, l, r, key);
		Pushup(rt);
	}
	
	LL GetSum(int rt, int l, int r) {
		if(r < node[rt].l || node[rt].r < l) return 0;
		if(l <= node[rt].l && node[rt].r <= r) return node[rt].sum;
		if(node[rt].lz) Pushdown(rt);
			
		int s = rt << 1;
		LL ret = GetSum(s, l, r) + GetSum(s+1, l, r);
		return Pushup(rt), ret;
	}
};

//20.10.25 
int dfn[MAXN], low[MAXN], clk = 0;
int bel_cnt[MAXN];
bool cut[MAXN];
std::stack<int> st;
void Tarjan(int u, int p)  {
	dfn[u] = low[u] = ++clk;
	if(!head[u]) return;
	
	st.push(u);
	int flag = 0;
	for(Edge* edg = head[u]; edg; edg = edg->nxt) {
		int v = edg->to;
		if(!dfn[v]) {
			Tarjan(v, u);
			low[u] = std::min(low[u], low[v]);
			if(low[v] >= dfn[u]) {
				++flag;
				if(u != p || flag > 1) cut[u] = true;
				int t;
				do t = st.top(), st.pop(), ++bel_cnt[t];
				while(t != v);
				++bel_cnt[u];
			}
		}
		else low[u] = std::min(low[u], dfn[v]);
	}
}

//20.11.04
//print bits of a data
void printbyte(char ch)  {
	int n = ch;
	for(int i = 7; i >= 0; --i)
		printf("%d", n >> i & 1);
	putchar(' ');
}

template<typename Type>
void display(Type a) {
	char s[MAXN];
	memcpy(s, &a, sizeof a);
	
	std::cout << "display: " << a << std::endl;
	for(int i = sizeof a - 1; i >= 0; --i)
		printbyte(s[i]);
}

//18.10.16
template<typename Type>
class Splay {
private:
	struct Node {
		typedef Node* iterator;
		Type key;
		int var_size;
		iterator prt, lch, rch;
		Node(const Type key):
			key(key), var_size(1), prt(NULL), lch(NULL), rch(NULL) {}
		int size() const {return this ? var_size : 0;}
		void update() {
			if(!this) return;
			var_size = lch->size() + rch->size() + 1;
		}
	};
	typedef Node* iterator;
	iterator Root;
	
	void RotateLeft(const iterator p) {
		iterator q = p->rch;
		q->prt = p->prt;
		if(!p->prt) Root = q;
		else if(p == p->prt->lch) p->prt->lch = q;
		else p->prt->rch = q;
		
		p->rch = q->lch;
		if(p->rch) p->rch->prt = p;
		q->lch = p, p->prt = q;
		p->update(), q->update();
	}
	
	void RotateRight(const iterator p) {
		iterator q = p->lch;
		q->prt = p->prt;
		if(!p->prt) Root = q;
		else if(p == p->prt->lch) p->prt->lch = q;
		else p->prt->rch = q;
		
		p->lch = q->rch;
		if(p->lch) p->lch->prt = p;
		q->rch = p, p->prt = q;
		p->update(), q->update();
	}
	
	void Splaying(iterator p, iterator top) {
		while(p->prt != top)
			if(p->prt->prt == top)
				if(p == p->prt->lch) RotateRight(p->prt);
				else RotateLeft(p->prt);
			else
				if(p->prt == p->prt->prt->lch)
					if(p == p->prt->lch) RotateRight(p->prt->prt), RotateRight(p->prt);
					else RotateLeft(p->prt), RotateRight(p->prt);
				else
					if(p == p->prt->lch) RotateRight(p->prt), RotateLeft(p->prt);
					else RotateLeft(p->prt->prt), RotateLeft(p->prt);
	}
	
public:
	Splay() {
		Root = new Node(-INF);
		Root->rch = new Node(INF);
		Root->rch->prt = Root;
		Root->rch->update();
		Root->update();
	}
	
	void insert(const Type key) {
		int pre_rank = rank(key) - 1;
		Splaying(Kth(pre_rank), NULL);
		Splaying(Kth(pre_rank+1), Root);
		iterator p = new Node(key);
		Root->rch->lch = p, p->prt = Root->rch;
		Root->rch->update(), Root->update();
	}
	
	void erase(const Type key) {
		int rank = Splay::rank(key);
		Splaying(Kth(rank-1), NULL);
		Splaying(Kth(rank+1), Root);
		delete Root->rch->lch;
		Root->rch->lch = NULL;
		Root->rch->update();
		Root->update();
	}
	
	int rank(const Type key) {
		int rank = 1;
		iterator p = Root;
		while(p)
			if(key <= p->key) p = p->lch;
			else rank += p->lch->size()+1, p = p->rch;
		return rank;
	}
	
	iterator Kth(int rank) {
		iterator p = Root;
		while(p) {
			int cnt = p->lch->size()+1;
			if(rank < cnt) p = p->lch;
			else if(rank == cnt) return p;
			else rank -= cnt, p = p->rch;
		}
		return NULL;
	}
};

//18.10.09
template<typename Type>
class Treap {
private:
	struct Node {
	typedef Node* iterator;
		Type key;
		int var_val, var_size;
		iterator lch, rch;
		Node(Type key):	key(key), var_val(rand()), var_size(1), lch(NULL), rch(NULL) {}
		int size() const {return this ? var_size : 0;}
		int val() const {return this ? var_val : 0;}
		void update() {var_size = lch->size() + rch->size() + 1;}
	};
	typedef Node* iterator;
	iterator Root;
	
	void RotateRight(iterator& p) {
		iterator q = p->lch;
		p->lch = q->rch, q->rch = p, p = q;
		p->rch->update(), p->update();
	}
	
	void RotateLeft(iterator& p) {
		iterator q = p->rch;
		p->rch = q->lch, q->lch = p, p = q;
		p->lch->update(), p->update();
	}
	
	void insert(iterator& p, const Type key) {//mine
		if(!p) return p = new Node(key), void();
		if(key <= p->key) {
			insert(p->lch, key);
			if(p->lch->val() > p->val())
				RotateRight(p);
		}
		else {
			insert(p->rch, key);
			if(p->rch->val() > p->val())
				RotateLeft(p);
		}
		p->update();
	}
	
	void erase(iterator& p, Type key) {
		if(key == p->key) {
			if(!p->lch && !p->rch)
				return p = NULL, void();
			if(!p->rch || p->lch->val() > p->rch->val())
				RotateRight(p), erase(p->rch, key);
			else RotateLeft(p), erase(p->lch, key);
		}
		else if(key < p->key) erase(p->lch, key);
		else erase(p->rch, key);
		p->update();
	}
	
public:
	void insert(int key) {insert(Root, key);}
	void erase(int key) {erase(Root, key);}
	
	int rank(const Type key) const {
		int rank = 1;
		iterator p = Root;
		while(p)
			if(key <= p->key) p = p->lch;
			else rank += p->lch->size()+1, p = p->rch;
		return rank;
	}
	
	iterator Kth(int rank) const {
		iterator p = Root;
		while(p){
			int cnt = p->lch->size()+1;
			if(rank<cnt) p=p->lch;
			else if(rank==cnt) return p;
			else rank -= cnt, p = p->rch;
		}
		return NULL;
	}
	
	int getpre(int key) {return Kth(rank(key)-1)->key;}
	int getsuf(int key) {return Kth(rank(key+1))->key;}
	Treap() {Root = NULL;}
};

int main() {
#ifdef EagleBear
	freopen("test.in", "r", stdin);
//	freopen("test.out", "w", stdout);
#endif

	std::ios::sync_with_stdio(false);
	srand(time(NULL));
	
#ifdef EagleBear
	fclose(stdin), fclose(stdout);
#endif
	return 0;
}

// 21.01.25
void quicksort(int* a, int l, int r) {
	if (l >= r) return;
	int i = l, j = r, p = a[l];
	while (i < j) {
		while (a[j] >= p && i < j) --j;
		while (a[i] <= p && i < j) ++i;
		if (i < j) a[i] ^= a[j], a[j] ^= a[i], a[i] ^= a[j];
	}
	a[l] = a[i], a[i] = p;
	quicksort(a, l, i-1);
	quicksort(a, i+1, r);
}

// 21.01.26
const int BASE = 65536;
std::stack<int> bkt[BASE];
void radixsort(int* a, int n) {
	int sum[BASE] = {0};
	for (int i = 1; i <= n; ++i)
		bkt[a[i] % BASE].push(a[i]), sum[a[i] / BASE]++;
	for (int i = 1; i < BASE; ++i)
		sum[i] += sum[i-1];
	for (int i = 0; i < BASE; ++i) while (!bkt[i].empty()) {
		int t = bkt[i].top();
		bkt[i].pop();
		a[++sum[t/BASE-1]] = t;
	}
}
